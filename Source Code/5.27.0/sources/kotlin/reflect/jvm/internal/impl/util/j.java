package kotlin.reflect.jvm.internal.impl.util;

import java.util.Set;
import kotlin.jvm.internal.i;
import kotlin.reflect.jvm.internal.impl.name.f;
import kotlin.text.Regex;

/* compiled from: OperatorNameConventions.kt */
public final class j {
    public static final f fyH;
    public static final f fyI;
    public static final f fyJ;
    public static final f fyK;
    public static final f fyL;
    public static final f fyM;
    public static final f fyN;
    public static final f fyO;
    public static final f fyP;
    public static final f fyQ;
    public static final f fyR;
    public static final f fyS;
    public static final Regex fyT = new Regex("component\\d+");
    public static final f fyU;
    public static final f fyV;
    public static final f fyW;
    public static final f fyX;
    public static final f fyY;
    public static final f fyZ;
    public static final f fza;
    public static final f fzb;
    public static final f fzc;
    public static final f fzd;
    public static final f fze;
    public static final f fzf;
    public static final f fzg;
    public static final f fzh;
    public static final f fzi;
    public static final f fzj;
    public static final f fzk;
    public static final f fzl;
    public static final f fzm;
    public static final f fzn;
    public static final Set<f> fzo = al.setOf(fyW, fyX, fzc, fzb, fza);
    public static final Set<f> fzp = al.setOf(fzc, fzb, fza);
    public static final Set<f> fzq = al.setOf(fzd, fyY, fyZ, fze, fzf, fzg, fzh);
    public static final Set<f> fzr = al.setOf(fzi, fzj, fzk, fzl, fzm, fzn);
    public static final j fzs = new j();

    static {
        f ms = f.ms("getValue");
        i.e(ms, "Name.identifier(\"getValue\")");
        fyH = ms;
        ms = f.ms("setValue");
        i.e(ms, "Name.identifier(\"setValue\")");
        fyI = ms;
        ms = f.ms("provideDelegate");
        i.e(ms, "Name.identifier(\"provideDelegate\")");
        fyJ = ms;
        ms = f.ms("equals");
        i.e(ms, "Name.identifier(\"equals\")");
        fyK = ms;
        ms = f.ms("compareTo");
        i.e(ms, "Name.identifier(\"compareTo\")");
        fyL = ms;
        ms = f.ms("contains");
        i.e(ms, "Name.identifier(\"contains\")");
        fyM = ms;
        ms = f.ms("invoke");
        i.e(ms, "Name.identifier(\"invoke\")");
        fyN = ms;
        ms = f.ms("iterator");
        i.e(ms, "Name.identifier(\"iterator\")");
        fyO = ms;
        ms = f.ms("get");
        i.e(ms, "Name.identifier(\"get\")");
        fyP = ms;
        ms = f.ms("set");
        i.e(ms, "Name.identifier(\"set\")");
        fyQ = ms;
        ms = f.ms("next");
        i.e(ms, "Name.identifier(\"next\")");
        fyR = ms;
        ms = f.ms("hasNext");
        i.e(ms, "Name.identifier(\"hasNext\")");
        fyS = ms;
        ms = f.ms("and");
        i.e(ms, "Name.identifier(\"and\")");
        fyU = ms;
        ms = f.ms("or");
        i.e(ms, "Name.identifier(\"or\")");
        fyV = ms;
        ms = f.ms("inc");
        i.e(ms, "Name.identifier(\"inc\")");
        fyW = ms;
        ms = f.ms("dec");
        i.e(ms, "Name.identifier(\"dec\")");
        fyX = ms;
        ms = f.ms("plus");
        i.e(ms, "Name.identifier(\"plus\")");
        fyY = ms;
        ms = f.ms("minus");
        i.e(ms, "Name.identifier(\"minus\")");
        fyZ = ms;
        ms = f.ms("not");
        i.e(ms, "Name.identifier(\"not\")");
        fza = ms;
        ms = f.ms("unaryMinus");
        i.e(ms, "Name.identifier(\"unaryMinus\")");
        fzb = ms;
        ms = f.ms("unaryPlus");
        i.e(ms, "Name.identifier(\"unaryPlus\")");
        fzc = ms;
        ms = f.ms("times");
        i.e(ms, "Name.identifier(\"times\")");
        fzd = ms;
        ms = f.ms("div");
        i.e(ms, "Name.identifier(\"div\")");
        fze = ms;
        ms = f.ms("mod");
        i.e(ms, "Name.identifier(\"mod\")");
        fzf = ms;
        ms = f.ms("rem");
        i.e(ms, "Name.identifier(\"rem\")");
        fzg = ms;
        ms = f.ms("rangeTo");
        i.e(ms, "Name.identifier(\"rangeTo\")");
        fzh = ms;
        ms = f.ms("timesAssign");
        i.e(ms, "Name.identifier(\"timesAssign\")");
        fzi = ms;
        ms = f.ms("divAssign");
        i.e(ms, "Name.identifier(\"divAssign\")");
        fzj = ms;
        ms = f.ms("modAssign");
        i.e(ms, "Name.identifier(\"modAssign\")");
        fzk = ms;
        ms = f.ms("remAssign");
        i.e(ms, "Name.identifier(\"remAssign\")");
        fzl = ms;
        ms = f.ms("plusAssign");
        i.e(ms, "Name.identifier(\"plusAssign\")");
        fzm = ms;
        ms = f.ms("minusAssign");
        i.e(ms, "Name.identifier(\"minusAssign\")");
        fzn = ms;
    }

    private j() {
    }
}
